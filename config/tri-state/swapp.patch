From 3ae503924cb0c23bfcdeb0e717c6986bf415b11c Mon Sep 17 00:00:00 2001
From: Nick Conway <nick@conway.dev>
Date: Mon, 27 Jun 2022 22:13:25 -0400
Subject: [PATCH 1/4] feat(behaviors) Add smart interrupt behavior

---
 app/CMakeLists.txt                            |   1 +
 app/Kconfig                                   |   6 +
 .../zmk,behavior-smart-interrupt.yaml         |  21 ++
 app/src/behaviors/behavior_smart_interrupt.c  | 222 ++++++++++++++++++
 4 files changed, 250 insertions(+)
 create mode 100644 app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
 create mode 100644 app/src/behaviors/behavior_smart_interrupt.c

diff --git a/app/CMakeLists.txt b/app/CMakeLists.txt
index 4b61fc7..e571310 100644
--- a/app/CMakeLists.txt
+++ b/app/CMakeLists.txt
@@ -51,6 +51,7 @@ if ((NOT CONFIG_ZMK_SPLIT) OR CONFIG_ZMK_SPLIT_ROLE_CENTRAL)
   target_sources(app PRIVATE src/behaviors/behavior_toggle_layer.c)
   target_sources(app PRIVATE src/behaviors/behavior_to_layer.c)
   target_sources(app PRIVATE src/behaviors/behavior_transparent.c)
+  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_SMART_INTERRUPT app PRIVATE src/behaviors/behavior_smart_interrupt.c)
   target_sources(app PRIVATE src/behaviors/behavior_none.c)
   target_sources(app PRIVATE src/behaviors/behavior_sensor_rotate_key_press.c)
   target_sources(app PRIVATE src/combo.c)
diff --git a/app/Kconfig b/app/Kconfig
index f89d327..6acac3d 100644
--- a/app/Kconfig
+++ b/app/Kconfig
@@ -343,6 +343,12 @@ config ZMK_BEHAVIOR_KEY_TOGGLE
         bool
         default $(dt_compat_enabled,$(DT_COMPAT_ZMK_BEHAVIOR_KEY_TOGGLE))
 
+DT_COMPAT_ZMK_BEHAVIOR_SMART_INTERRUPT := zmk,behavior-smart-interrupt
+
+config ZMK_BEHAVIOR_SMART_INTERRUPT
+        bool
+        default $(dt_compat_enabled,$(DT_COMPAT_ZMK_BEHAVIOR_SMART_INTERRUPT))
+
 endmenu
 
 menu "Advanced"
diff --git a/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml b/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
new file mode 100644
index 0000000..5a1ea3c
--- /dev/null
+++ b/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
@@ -0,0 +1,21 @@
+# Copyright (c) 2022 The ZMK Contributors
+# SPDX-License-Identifier: MIT
+
+description: Smart Interrupt Behavior
+
+compatible: "zmk,behavior-smart-interrupt"
+
+include: zero_param.yaml
+
+properties:
+  bindings:
+    type: phandle-array
+    required: true
+  shared-key-positions:
+    type: array
+    required: false
+    default: []
+  shared-layers:
+    type: array
+    required: false
+    default: []
diff --git a/app/src/behaviors/behavior_smart_interrupt.c b/app/src/behaviors/behavior_smart_interrupt.c
new file mode 100644
index 0000000..db4a02e
--- /dev/null
+++ b/app/src/behaviors/behavior_smart_interrupt.c
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2022 The ZMK Contributors
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#define DT_DRV_COMPAT zmk_behavior_smart_interrupt
+
+#include <device.h>
+#include <drivers/behavior.h>
+#include <logging/log.h>
+#include <zmk/behavior.h>
+#include <zmk/keymap.h>
+#include <zmk/matrix.h>
+#include <zmk/event_manager.h>
+#include <zmk/events/position_state_changed.h>
+#include <zmk/events/layer_state_changed.h>
+#include <zmk/hid.h>
+
+LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
+
+#define ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS 10
+
+struct behavior_smart_interrupt_config {
+    int32_t shared_key_positions_len;
+    int32_t shared_layers_len;
+    struct zmk_behavior_binding *behaviors;
+    int32_t shared_layers[32];
+    int32_t shared_key_positions[];
+};
+
+struct active_smart_interrupt {
+    bool is_active;
+    bool is_pressed;
+    bool first_press;
+    uint32_t position;
+    const struct behavior_smart_interrupt_config *config;
+};
+
+struct active_smart_interrupt active_smart_interruptes[ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS] = {};
+
+static struct active_smart_interrupt *find_smart_interrupt(uint32_t position) {
+    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
+        if (active_smart_interruptes[i].position == position &&
+            active_smart_interruptes[i].is_active) {
+            return &active_smart_interruptes[i];
+        }
+    }
+    return NULL;
+}
+
+static int new_smart_interrupt(uint32_t position,
+                               const struct behavior_smart_interrupt_config *config,
+                               struct active_smart_interrupt **smart_interrupt) {
+    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
+        struct active_smart_interrupt *const ref_smart_interrupt = &active_smart_interruptes[i];
+        if (!ref_smart_interrupt->is_active) {
+            ref_smart_interrupt->position = position;
+            ref_smart_interrupt->config = config;
+            ref_smart_interrupt->is_active = true;
+            ref_smart_interrupt->is_pressed = false;
+            ref_smart_interrupt->first_press = true;
+            *smart_interrupt = ref_smart_interrupt;
+            return 0;
+        }
+    }
+    return -ENOMEM;
+}
+
+static bool is_other_key_shared(struct active_smart_interrupt *smart_interrupt, int32_t position) {
+    for (int i = 0; i < smart_interrupt->config->shared_key_positions_len; i++) {
+        if (smart_interrupt->config->shared_key_positions[i] == position) {
+            return true;
+        }
+    }
+    return false;
+}
+
+static bool is_layer_shared(struct active_smart_interrupt *smart_interrupt, int32_t layer) {
+    for (int i = 0; i < smart_interrupt->config->shared_layers_len; i++) {
+        if (smart_interrupt->config->shared_layers[i] == layer) {
+            return true;
+        }
+    }
+    return false;
+}
+
+static int on_smart_interrupt_binding_pressed(struct zmk_behavior_binding *binding,
+                                              struct zmk_behavior_binding_event event) {
+    const struct device *dev = device_get_binding(binding->behavior_dev);
+    const struct behavior_smart_interrupt_config *cfg = dev->config;
+    struct active_smart_interrupt *smart_interrupt;
+    smart_interrupt = find_smart_interrupt(event.position);
+    if (smart_interrupt == NULL) {
+        if (new_smart_interrupt(event.position, cfg, &smart_interrupt) == -ENOMEM) {
+            LOG_ERR("Unable to create new smart_interrupt. Insufficient space in "
+                    "active_smart_interruptes[].");
+            return ZMK_BEHAVIOR_OPAQUE;
+        }
+        LOG_DBG("%d created new smart_interrupt", event.position);
+    }
+    LOG_DBG("%d smart_interrupt pressed", event.position);
+    smart_interrupt->is_pressed = true;
+    if (smart_interrupt->first_press) {
+        behavior_keymap_binding_pressed(&cfg->behaviors[0], event);
+        behavior_keymap_binding_released(&cfg->behaviors[0], event);
+        smart_interrupt->first_press = false;
+    }
+    behavior_keymap_binding_pressed(&cfg->behaviors[1], event);
+    return ZMK_BEHAVIOR_OPAQUE;
+}
+
+static int on_smart_interrupt_binding_released(struct zmk_behavior_binding *binding,
+                                               struct zmk_behavior_binding_event event) {
+    const struct device *dev = device_get_binding(binding->behavior_dev);
+    const struct behavior_smart_interrupt_config *cfg = dev->config;
+    LOG_DBG("%d smart_interrupt keybind released", event.position);
+    struct active_smart_interrupt *smart_interrupt = find_smart_interrupt(event.position);
+    if (smart_interrupt == NULL) {
+        return ZMK_BEHAVIOR_OPAQUE;
+    }
+    smart_interrupt->is_pressed = false;
+    behavior_keymap_binding_released(&cfg->behaviors[1], event);
+    return ZMK_BEHAVIOR_OPAQUE;
+}
+
+static int smart_interrupt_init(const struct device *dev) { return 0; }
+
+static const struct behavior_driver_api behavior_smart_interrupt_driver_api = {
+    .binding_pressed = on_smart_interrupt_binding_pressed,
+    .binding_released = on_smart_interrupt_binding_released,
+};
+
+static int smart_interrupt_position_state_changed_listener(const zmk_event_t *eh);
+static int smart_interrupt_layer_state_changed_listener(const zmk_event_t *eh);
+
+ZMK_LISTENER(behavior_smart_interrupt, smart_interrupt_position_state_changed_listener);
+ZMK_SUBSCRIPTION(behavior_smart_interrupt, zmk_position_state_changed);
+
+ZMK_LISTENER(behavior_smart_interrupt2, smart_interrupt_layer_state_changed_listener);
+ZMK_SUBSCRIPTION(behavior_smart_interrupt2, zmk_layer_state_changed);
+
+static int smart_interrupt_position_state_changed_listener(const zmk_event_t *eh) {
+    struct zmk_position_state_changed *ev = as_zmk_position_state_changed(eh);
+    if (ev == NULL) {
+        return ZMK_EV_EVENT_BUBBLE;
+    }
+    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
+        struct active_smart_interrupt *smart_interrupt = &active_smart_interruptes[i];
+        if (!smart_interrupt->is_active) {
+            continue;
+        }
+        if (smart_interrupt->position == ev->position) {
+            continue;
+        }
+        if (!is_other_key_shared(smart_interrupt, ev->position)) {
+            LOG_DBG("Smart Interrupt interrupted, ending at %d %d", smart_interrupt->position,
+                    ev->position);
+            smart_interrupt->is_active = false;
+            struct zmk_behavior_binding_event event = {.position = smart_interrupt->position,
+                                                       .timestamp = k_uptime_get()};
+            if (smart_interrupt->is_pressed) {
+                behavior_keymap_binding_released(&smart_interrupt->config->behaviors[1], event);
+            }
+            behavior_keymap_binding_pressed(&smart_interrupt->config->behaviors[2], event);
+            behavior_keymap_binding_released(&smart_interrupt->config->behaviors[2], event);
+            return ZMK_EV_EVENT_BUBBLE;
+        }
+    }
+    return ZMK_EV_EVENT_BUBBLE;
+}
+
+static int smart_interrupt_layer_state_changed_listener(const zmk_event_t *eh) {
+    struct zmk_layer_state_changed *ev = as_zmk_layer_state_changed(eh);
+    if (ev == NULL) {
+        return ZMK_EV_EVENT_BUBBLE;
+    }
+    if (!ev->state) {
+        return ZMK_EV_EVENT_BUBBLE;
+    }
+    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
+        struct active_smart_interrupt *smart_interrupt = &active_smart_interruptes[i];
+        if (!smart_interrupt->is_active) {
+            continue;
+        }
+        if (!is_layer_shared(smart_interrupt, ev->layer)) {
+            LOG_DBG("Smart Interrupt layer changed, ending at %d %d", smart_interrupt->position,
+                    ev->layer);
+            smart_interrupt->is_active = false;
+            struct zmk_behavior_binding_event event = {.position = smart_interrupt->position,
+                                                       .timestamp = k_uptime_get()};
+            if (smart_interrupt->is_pressed) {
+                behavior_keymap_binding_released(&smart_interrupt->config->behaviors[1], event);
+            }
+            behavior_keymap_binding_pressed(&smart_interrupt->config->behaviors[2], event);
+            behavior_keymap_binding_released(&smart_interrupt->config->behaviors[2], event);
+            return ZMK_EV_EVENT_BUBBLE;
+        }
+    }
+    return ZMK_EV_EVENT_BUBBLE;
+}
+
+#define _TRANSFORM_ENTRY(idx, node) ZMK_KEYMAP_EXTRACT_BINDING(idx, node),
+
+#define TRANSFORMED_BINDINGS(node)                                                                 \
+    { UTIL_LISTIFY(DT_INST_PROP_LEN(node, bindings), _TRANSFORM_ENTRY, DT_DRV_INST(node)) }
+
+#define SMART_INTERRUPT_INST(n)                                                                    \
+    static struct zmk_behavior_binding                                                             \
+        behavior_smart_interrupt_config_##n##_bindings[DT_INST_PROP_LEN(n, bindings)] =            \
+            TRANSFORMED_BINDINGS(n);                                                               \
+    static struct behavior_smart_interrupt_config behavior_smart_interrupt_config_##n = {          \
+        .shared_key_positions = DT_INST_PROP(n, shared_key_positions),                             \
+        .shared_key_positions_len = DT_INST_PROP_LEN(n, shared_key_positions),                     \
+        .shared_layers = DT_INST_PROP(n, shared_layers),                                           \
+        .shared_layers_len = DT_INST_PROP_LEN(n, shared_layers),                                   \
+        .behaviors = behavior_smart_interrupt_config_##n##_bindings};                              \
+    DEVICE_DT_INST_DEFINE(                                                                         \
+        n, smart_interrupt_init, NULL, NULL, &behavior_smart_interrupt_config_##n, APPLICATION,    \
+        CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, &behavior_smart_interrupt_driver_api);
+
+DT_INST_FOREACH_STATUS_OKAY(SMART_INTERRUPT_INST)
-- 
2.30.2


From 76adeac23219969b7f3ed1e0385cf4c536ae053e Mon Sep 17 00:00:00 2001
From: Nick Conway <nick@conway.dev>
Date: Fri, 22 Jul 2022 19:26:00 -0400
Subject: [PATCH 2/4] Add timeout option for smart interrupt behavior

---
 .../zmk,behavior-smart-interrupt.yaml         |  3 +
 app/src/behaviors/behavior_smart_interrupt.c  | 88 ++++++++++++++++---
 2 files changed, 80 insertions(+), 11 deletions(-)

diff --git a/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml b/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
index 5a1ea3c..e3f7c72 100644
--- a/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
+++ b/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
@@ -19,3 +19,6 @@ properties:
     type: array
     required: false
     default: []
+  timeout-ms:
+    type: int
+    default: -1
diff --git a/app/src/behaviors/behavior_smart_interrupt.c b/app/src/behaviors/behavior_smart_interrupt.c
index db4a02e..4131340 100644
--- a/app/src/behaviors/behavior_smart_interrupt.c
+++ b/app/src/behaviors/behavior_smart_interrupt.c
@@ -26,6 +26,7 @@ struct behavior_smart_interrupt_config {
     int32_t shared_layers_len;
     struct zmk_behavior_binding *behaviors;
     int32_t shared_layers[32];
+    int32_t timeout_ms;
     int32_t shared_key_positions[];
 };
 
@@ -35,15 +36,61 @@ struct active_smart_interrupt {
     bool first_press;
     uint32_t position;
     const struct behavior_smart_interrupt_config *config;
+    struct k_work_delayable release_timer;
+    int64_t release_at;
+    bool timer_started;
+    bool timer_cancelled;
 };
 
-struct active_smart_interrupt active_smart_interruptes[ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS] = {};
+static int stop_timer(struct active_smart_interrupt *smart_interrupt) {
+    int timer_cancel_result = k_work_cancel_delayable(&smart_interrupt->release_timer);
+    if (timer_cancel_result == -EINPROGRESS) {
+        // too late to cancel, we'll let the timer handler clear up.
+        smart_interrupt->timer_cancelled = true;
+    }
+    return timer_cancel_result;
+}
+
+static void reset_timer(int32_t timestamp, struct active_smart_interrupt *smart_interrupt) {
+    smart_interrupt->release_at = timestamp + smart_interrupt->config->timeout_ms;
+    int32_t ms_left = smart_interrupt->release_at - k_uptime_get();
+    if (ms_left > 0) {
+        k_work_schedule(&smart_interrupt->release_timer, K_MSEC(ms_left));
+        LOG_DBG("Successfully reset smart interrupt timer");
+    }
+}
+
+void behavior_smart_interrupt_timer_handler(struct k_work *item) {
+    struct active_smart_interrupt *smart_interrupt =
+        CONTAINER_OF(item, struct active_smart_interrupt, release_timer);
+    if (!smart_interrupt->is_active) {
+        return;
+    }
+    if (smart_interrupt->timer_cancelled) {
+        return;
+    }
+    if (smart_interrupt->is_pressed) {
+        return;
+    }
+    LOG_DBG("Smart interrupted deactivated due to timer");
+    smart_interrupt->is_active = false;
+    struct zmk_behavior_binding_event event = {.position = smart_interrupt->position,
+                                               .timestamp = k_uptime_get()};
+    behavior_keymap_binding_pressed(&smart_interrupt->config->behaviors[2], event);
+    behavior_keymap_binding_released(&smart_interrupt->config->behaviors[2], event);
+}
+
+static void clear_smart_interrupt(struct active_smart_interrupt *smart_interrupt) {
+    smart_interrupt->is_active = false;
+}
+
+struct active_smart_interrupt active_smart_interrupts[ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS] = {};
 
 static struct active_smart_interrupt *find_smart_interrupt(uint32_t position) {
     for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
-        if (active_smart_interruptes[i].position == position &&
-            active_smart_interruptes[i].is_active) {
-            return &active_smart_interruptes[i];
+        if (active_smart_interrupts[i].position == position &&
+            active_smart_interrupts[i].is_active) {
+            return &active_smart_interrupts[i];
         }
     }
     return NULL;
@@ -53,7 +100,7 @@ static int new_smart_interrupt(uint32_t position,
                                const struct behavior_smart_interrupt_config *config,
                                struct active_smart_interrupt **smart_interrupt) {
     for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
-        struct active_smart_interrupt *const ref_smart_interrupt = &active_smart_interruptes[i];
+        struct active_smart_interrupt *const ref_smart_interrupt = &active_smart_interrupts[i];
         if (!ref_smart_interrupt->is_active) {
             ref_smart_interrupt->position = position;
             ref_smart_interrupt->config = config;
@@ -94,12 +141,13 @@ static int on_smart_interrupt_binding_pressed(struct zmk_behavior_binding *bindi
     if (smart_interrupt == NULL) {
         if (new_smart_interrupt(event.position, cfg, &smart_interrupt) == -ENOMEM) {
             LOG_ERR("Unable to create new smart_interrupt. Insufficient space in "
-                    "active_smart_interruptes[].");
+                    "active_smart_interrupts[].");
             return ZMK_BEHAVIOR_OPAQUE;
         }
         LOG_DBG("%d created new smart_interrupt", event.position);
     }
     LOG_DBG("%d smart_interrupt pressed", event.position);
+    stop_timer(smart_interrupt);
     smart_interrupt->is_pressed = true;
     if (smart_interrupt->first_press) {
         behavior_keymap_binding_pressed(&cfg->behaviors[0], event);
@@ -121,10 +169,22 @@ static int on_smart_interrupt_binding_released(struct zmk_behavior_binding *bind
     }
     smart_interrupt->is_pressed = false;
     behavior_keymap_binding_released(&cfg->behaviors[1], event);
+    reset_timer(k_uptime_get(), smart_interrupt);
     return ZMK_BEHAVIOR_OPAQUE;
 }
 
-static int smart_interrupt_init(const struct device *dev) { return 0; }
+static int behavior_smart_interrupt_init(const struct device *dev) {
+    static bool init_first_run = true;
+    if (init_first_run) {
+        for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
+            k_work_init_delayable(&active_smart_interrupts[i].release_timer,
+                                  behavior_smart_interrupt_timer_handler);
+            clear_smart_interrupt(&active_smart_interrupts[i]);
+        }
+    }
+    init_first_run = false;
+    return 0;
+}
 
 static const struct behavior_driver_api behavior_smart_interrupt_driver_api = {
     .binding_pressed = on_smart_interrupt_binding_pressed,
@@ -146,7 +206,7 @@ static int smart_interrupt_position_state_changed_listener(const zmk_event_t *eh
         return ZMK_EV_EVENT_BUBBLE;
     }
     for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
-        struct active_smart_interrupt *smart_interrupt = &active_smart_interruptes[i];
+        struct active_smart_interrupt *smart_interrupt = &active_smart_interrupts[i];
         if (!smart_interrupt->is_active) {
             continue;
         }
@@ -166,6 +226,11 @@ static int smart_interrupt_position_state_changed_listener(const zmk_event_t *eh
             behavior_keymap_binding_released(&smart_interrupt->config->behaviors[2], event);
             return ZMK_EV_EVENT_BUBBLE;
         }
+        if (ev->state) {
+            stop_timer(smart_interrupt);
+        } else {
+            reset_timer(ev->timestamp, smart_interrupt);
+        }
     }
     return ZMK_EV_EVENT_BUBBLE;
 }
@@ -179,7 +244,7 @@ static int smart_interrupt_layer_state_changed_listener(const zmk_event_t *eh) {
         return ZMK_EV_EVENT_BUBBLE;
     }
     for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
-        struct active_smart_interrupt *smart_interrupt = &active_smart_interruptes[i];
+        struct active_smart_interrupt *smart_interrupt = &active_smart_interrupts[i];
         if (!smart_interrupt->is_active) {
             continue;
         }
@@ -214,9 +279,10 @@ static int smart_interrupt_layer_state_changed_listener(const zmk_event_t *eh) {
         .shared_key_positions_len = DT_INST_PROP_LEN(n, shared_key_positions),                     \
         .shared_layers = DT_INST_PROP(n, shared_layers),                                           \
         .shared_layers_len = DT_INST_PROP_LEN(n, shared_layers),                                   \
+        .timeout_ms = DT_INST_PROP(n, timeout_ms),                                                 \
         .behaviors = behavior_smart_interrupt_config_##n##_bindings};                              \
     DEVICE_DT_INST_DEFINE(                                                                         \
-        n, smart_interrupt_init, NULL, NULL, &behavior_smart_interrupt_config_##n, APPLICATION,    \
-        CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, &behavior_smart_interrupt_driver_api);
+        n, behavior_smart_interrupt_init, NULL, NULL, &behavior_smart_interrupt_config_##n,        \
+        APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, &behavior_smart_interrupt_driver_api);
 
 DT_INST_FOREACH_STATUS_OKAY(SMART_INTERRUPT_INST)
-- 
2.30.2


From f12a070a02e3eccc4c5c5808ad63d33efd79b23d Mon Sep 17 00:00:00 2001
From: Nick Conway <nick@conway.dev>
Date: Fri, 29 Jul 2022 02:10:01 -0400
Subject: [PATCH 3/4] Implement suggestion from code review

---
 .../zmk,behavior-smart-interrupt.yaml         |   7 +-
 app/src/behaviors/behavior_smart_interrupt.c  | 137 ++++++++++--------
 2 files changed, 85 insertions(+), 59 deletions(-)

diff --git a/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml b/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
index e3f7c72..287557d 100644
--- a/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
+++ b/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
@@ -11,14 +11,17 @@ properties:
   bindings:
     type: phandle-array
     required: true
-  shared-key-positions:
+  ignored-key-positions:
     type: array
     required: false
     default: []
-  shared-layers:
+  ignored-layers:
     type: array
     required: false
     default: []
   timeout-ms:
     type: int
     default: -1
+  tap-ms:
+    type: int
+    default: 5
diff --git a/app/src/behaviors/behavior_smart_interrupt.c b/app/src/behaviors/behavior_smart_interrupt.c
index 4131340..f56fcac 100644
--- a/app/src/behaviors/behavior_smart_interrupt.c
+++ b/app/src/behaviors/behavior_smart_interrupt.c
@@ -10,6 +10,7 @@
 #include <drivers/behavior.h>
 #include <logging/log.h>
 #include <zmk/behavior.h>
+#include <zmk/behavior_queue.h>
 #include <zmk/keymap.h>
 #include <zmk/matrix.h>
 #include <zmk/event_manager.h>
@@ -22,12 +23,15 @@ LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
 #define ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS 10
 
 struct behavior_smart_interrupt_config {
-    int32_t shared_key_positions_len;
-    int32_t shared_layers_len;
-    struct zmk_behavior_binding *behaviors;
-    int32_t shared_layers[32];
+    int32_t ignored_key_positions_len;
+    int32_t ignored_layers_len;
+    struct zmk_behavior_binding start_behavior;
+    struct zmk_behavior_binding continue_behavior;
+    struct zmk_behavior_binding end_behavior;
+    int32_t ignored_layers;
     int32_t timeout_ms;
-    int32_t shared_key_positions[];
+    int tap_ms;
+    uint8_t ignored_key_positions[];
 };
 
 struct active_smart_interrupt {
@@ -60,24 +64,21 @@ static void reset_timer(int32_t timestamp, struct active_smart_interrupt *smart_
     }
 }
 
+void trigger_end_behavior(struct active_smart_interrupt *si) {
+    zmk_behavior_queue_add(si->position, si->config->end_behavior, true, si->config->tap_ms);
+    zmk_behavior_queue_add(si->position, si->config->end_behavior, false, 0);
+}
+
 void behavior_smart_interrupt_timer_handler(struct k_work *item) {
     struct active_smart_interrupt *smart_interrupt =
         CONTAINER_OF(item, struct active_smart_interrupt, release_timer);
-    if (!smart_interrupt->is_active) {
-        return;
-    }
-    if (smart_interrupt->timer_cancelled) {
-        return;
-    }
-    if (smart_interrupt->is_pressed) {
+    if (!smart_interrupt->is_active || smart_interrupt->timer_cancelled ||
+        smart_interrupt->is_pressed) {
         return;
     }
     LOG_DBG("Smart interrupted deactivated due to timer");
     smart_interrupt->is_active = false;
-    struct zmk_behavior_binding_event event = {.position = smart_interrupt->position,
-                                               .timestamp = k_uptime_get()};
-    behavior_keymap_binding_pressed(&smart_interrupt->config->behaviors[2], event);
-    behavior_keymap_binding_released(&smart_interrupt->config->behaviors[2], event);
+    trigger_end_behavior(smart_interrupt);
 }
 
 static void clear_smart_interrupt(struct active_smart_interrupt *smart_interrupt) {
@@ -114,20 +115,18 @@ static int new_smart_interrupt(uint32_t position,
     return -ENOMEM;
 }
 
-static bool is_other_key_shared(struct active_smart_interrupt *smart_interrupt, int32_t position) {
-    for (int i = 0; i < smart_interrupt->config->shared_key_positions_len; i++) {
-        if (smart_interrupt->config->shared_key_positions[i] == position) {
+static bool is_other_key_ignored(struct active_smart_interrupt *smart_interrupt, int32_t position) {
+    for (int i = 0; i < smart_interrupt->config->ignored_key_positions_len; i++) {
+        if (smart_interrupt->config->ignored_key_positions[i] == position) {
             return true;
         }
     }
     return false;
 }
 
-static bool is_layer_shared(struct active_smart_interrupt *smart_interrupt, int32_t layer) {
-    for (int i = 0; i < smart_interrupt->config->shared_layers_len; i++) {
-        if (smart_interrupt->config->shared_layers[i] == layer) {
-            return true;
-        }
+static bool is_layer_ignored(struct active_smart_interrupt *smart_interrupt, int32_t layer) {
+    if ((BIT(layer) & smart_interrupt->config->ignored_layers) != 0U) {
+        return true;
     }
     return false;
 }
@@ -147,29 +146,34 @@ static int on_smart_interrupt_binding_pressed(struct zmk_behavior_binding *bindi
         LOG_DBG("%d created new smart_interrupt", event.position);
     }
     LOG_DBG("%d smart_interrupt pressed", event.position);
-    stop_timer(smart_interrupt);
     smart_interrupt->is_pressed = true;
     if (smart_interrupt->first_press) {
-        behavior_keymap_binding_pressed(&cfg->behaviors[0], event);
-        behavior_keymap_binding_released(&cfg->behaviors[0], event);
+        behavior_keymap_binding_pressed((struct zmk_behavior_binding *)&cfg->start_behavior, event);
+        behavior_keymap_binding_released((struct zmk_behavior_binding *)&cfg->start_behavior,
+                                         event);
         smart_interrupt->first_press = false;
     }
-    behavior_keymap_binding_pressed(&cfg->behaviors[1], event);
+    behavior_keymap_binding_pressed((struct zmk_behavior_binding *)&cfg->continue_behavior, event);
     return ZMK_BEHAVIOR_OPAQUE;
 }
 
-static int on_smart_interrupt_binding_released(struct zmk_behavior_binding *binding,
-                                               struct zmk_behavior_binding_event event) {
-    const struct device *dev = device_get_binding(binding->behavior_dev);
-    const struct behavior_smart_interrupt_config *cfg = dev->config;
-    LOG_DBG("%d smart_interrupt keybind released", event.position);
+static void release_smart_interrupt(struct zmk_behavior_binding_event event,
+                                    struct zmk_behavior_binding *continue_behavior) {
     struct active_smart_interrupt *smart_interrupt = find_smart_interrupt(event.position);
     if (smart_interrupt == NULL) {
-        return ZMK_BEHAVIOR_OPAQUE;
+        return;
     }
     smart_interrupt->is_pressed = false;
-    behavior_keymap_binding_released(&cfg->behaviors[1], event);
+    behavior_keymap_binding_released(continue_behavior, event);
     reset_timer(k_uptime_get(), smart_interrupt);
+}
+
+static int on_smart_interrupt_binding_released(struct zmk_behavior_binding *binding,
+                                               struct zmk_behavior_binding_event event) {
+    const struct device *dev = device_get_binding(binding->behavior_dev);
+    const struct behavior_smart_interrupt_config *cfg = dev->config;
+    LOG_DBG("%d smart_interrupt keybind released", event.position);
+    release_smart_interrupt(event, (struct zmk_behavior_binding *)&cfg->continue_behavior);
     return ZMK_BEHAVIOR_OPAQUE;
 }
 
@@ -191,14 +195,22 @@ static const struct behavior_driver_api behavior_smart_interrupt_driver_api = {
     .binding_released = on_smart_interrupt_binding_released,
 };
 
+static int smart_interrupt_listener(const zmk_event_t *eh);
 static int smart_interrupt_position_state_changed_listener(const zmk_event_t *eh);
 static int smart_interrupt_layer_state_changed_listener(const zmk_event_t *eh);
 
-ZMK_LISTENER(behavior_smart_interrupt, smart_interrupt_position_state_changed_listener);
+ZMK_LISTENER(behavior_smart_interrupt, smart_interrupt_listener);
 ZMK_SUBSCRIPTION(behavior_smart_interrupt, zmk_position_state_changed);
+ZMK_SUBSCRIPTION(behavior_smart_interrupt, zmk_layer_state_changed);
 
-ZMK_LISTENER(behavior_smart_interrupt2, smart_interrupt_layer_state_changed_listener);
-ZMK_SUBSCRIPTION(behavior_smart_interrupt2, zmk_layer_state_changed);
+static int smart_interrupt_listener(const zmk_event_t *eh) {
+    if (as_zmk_position_state_changed(eh) != NULL) {
+        return smart_interrupt_position_state_changed_listener(eh);
+    } else if (as_zmk_layer_state_changed(eh) != NULL) {
+        return smart_interrupt_layer_state_changed_listener(eh);
+    }
+    return ZMK_EV_EVENT_BUBBLE;
+}
 
 static int smart_interrupt_position_state_changed_listener(const zmk_event_t *eh) {
     struct zmk_position_state_changed *ev = as_zmk_position_state_changed(eh);
@@ -213,17 +225,18 @@ static int smart_interrupt_position_state_changed_listener(const zmk_event_t *eh
         if (smart_interrupt->position == ev->position) {
             continue;
         }
-        if (!is_other_key_shared(smart_interrupt, ev->position)) {
+        if (!is_other_key_ignored(smart_interrupt, ev->position)) {
             LOG_DBG("Smart Interrupt interrupted, ending at %d %d", smart_interrupt->position,
                     ev->position);
             smart_interrupt->is_active = false;
             struct zmk_behavior_binding_event event = {.position = smart_interrupt->position,
                                                        .timestamp = k_uptime_get()};
             if (smart_interrupt->is_pressed) {
-                behavior_keymap_binding_released(&smart_interrupt->config->behaviors[1], event);
+                behavior_keymap_binding_released(
+                    (struct zmk_behavior_binding *)&smart_interrupt->config->continue_behavior,
+                    event);
             }
-            behavior_keymap_binding_pressed(&smart_interrupt->config->behaviors[2], event);
-            behavior_keymap_binding_released(&smart_interrupt->config->behaviors[2], event);
+            trigger_end_behavior(smart_interrupt);
             return ZMK_EV_EVENT_BUBBLE;
         }
         if (ev->state) {
@@ -248,39 +261,49 @@ static int smart_interrupt_layer_state_changed_listener(const zmk_event_t *eh) {
         if (!smart_interrupt->is_active) {
             continue;
         }
-        if (!is_layer_shared(smart_interrupt, ev->layer)) {
+        if (!is_layer_ignored(smart_interrupt, ev->layer)) {
             LOG_DBG("Smart Interrupt layer changed, ending at %d %d", smart_interrupt->position,
                     ev->layer);
             smart_interrupt->is_active = false;
             struct zmk_behavior_binding_event event = {.position = smart_interrupt->position,
                                                        .timestamp = k_uptime_get()};
             if (smart_interrupt->is_pressed) {
-                behavior_keymap_binding_released(&smart_interrupt->config->behaviors[1], event);
+                behavior_keymap_binding_released(
+                    (struct zmk_behavior_binding *)&smart_interrupt->config->continue_behavior,
+                    event);
             }
-            behavior_keymap_binding_pressed(&smart_interrupt->config->behaviors[2], event);
-            behavior_keymap_binding_released(&smart_interrupt->config->behaviors[2], event);
+            behavior_keymap_binding_pressed(
+                (struct zmk_behavior_binding *)&smart_interrupt->config->end_behavior, event);
+            behavior_keymap_binding_released(
+                (struct zmk_behavior_binding *)&smart_interrupt->config->end_behavior, event);
             return ZMK_EV_EVENT_BUBBLE;
         }
     }
     return ZMK_EV_EVENT_BUBBLE;
 }
 
-#define _TRANSFORM_ENTRY(idx, node) ZMK_KEYMAP_EXTRACT_BINDING(idx, node),
+#define _TRANSFORM_ENTRY(idx, node)                                                                \
+    {                                                                                              \
+        .behavior_dev = DT_LABEL(DT_INST_PHANDLE_BY_IDX(node, bindings, idx)),                     \
+        .param1 = COND_CODE_0(DT_INST_PHA_HAS_CELL_AT_IDX(node, bindings, idx, param1), (0),       \
+                              (DT_INST_PHA_BY_IDX(node, bindings, idx, param1))),                  \
+        .param2 = COND_CODE_0(DT_INST_PHA_HAS_CELL_AT_IDX(node, bindings, idx, param2), (0),       \
+                              (DT_INST_PHA_BY_IDX(node, bindings, idx, param2))),                  \
+    }
 
-#define TRANSFORMED_BINDINGS(node)                                                                 \
-    { UTIL_LISTIFY(DT_INST_PROP_LEN(node, bindings), _TRANSFORM_ENTRY, DT_DRV_INST(node)) }
+#define IF_BIT(n, prop, i) BIT(DT_PROP_BY_IDX(n, prop, i)) |
 
 #define SMART_INTERRUPT_INST(n)                                                                    \
-    static struct zmk_behavior_binding                                                             \
-        behavior_smart_interrupt_config_##n##_bindings[DT_INST_PROP_LEN(n, bindings)] =            \
-            TRANSFORMED_BINDINGS(n);                                                               \
     static struct behavior_smart_interrupt_config behavior_smart_interrupt_config_##n = {          \
-        .shared_key_positions = DT_INST_PROP(n, shared_key_positions),                             \
-        .shared_key_positions_len = DT_INST_PROP_LEN(n, shared_key_positions),                     \
-        .shared_layers = DT_INST_PROP(n, shared_layers),                                           \
-        .shared_layers_len = DT_INST_PROP_LEN(n, shared_layers),                                   \
+        .ignored_key_positions = DT_INST_PROP(n, ignored_key_positions),                           \
+        .ignored_key_positions_len = DT_INST_PROP_LEN(n, ignored_key_positions),                   \
+        .ignored_layers = DT_INST_FOREACH_PROP_ELEM(n, ignored_layers, IF_BIT) 0,                  \
+        .ignored_layers_len = DT_INST_PROP_LEN(n, ignored_layers),                                 \
         .timeout_ms = DT_INST_PROP(n, timeout_ms),                                                 \
-        .behaviors = behavior_smart_interrupt_config_##n##_bindings};                              \
+        .tap_ms = DT_INST_PROP(n, tap_ms),                                                         \
+        .start_behavior = _TRANSFORM_ENTRY(0, n),                                                  \
+        .continue_behavior = _TRANSFORM_ENTRY(1, n),                                               \
+        .end_behavior = _TRANSFORM_ENTRY(2, n)};                                                   \
     DEVICE_DT_INST_DEFINE(                                                                         \
         n, behavior_smart_interrupt_init, NULL, NULL, &behavior_smart_interrupt_config_##n,        \
         APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, &behavior_smart_interrupt_driver_api);
-- 
2.30.2


From f0cc5c13754b93d106edf53c388cdc0583c9d20d Mon Sep 17 00:00:00 2001
From: Nick Conway <nick@conway.dev>
Date: Sat, 30 Jul 2022 18:36:24 -0400
Subject: [PATCH 4/4] Rename smart-interrupt to tri-state

---
 app/CMakeLists.txt                            |   2 +-
 app/Kconfig                                   |   6 +-
 ...rrupt.yaml => zmk,behavior-tri-state.yaml} |   4 +-
 app/src/behaviors/behavior_smart_interrupt.c  | 311 ------------------
 app/src/behaviors/behavior_tri_state.c        | 301 +++++++++++++++++
 5 files changed, 307 insertions(+), 317 deletions(-)
 rename app/dts/bindings/behaviors/{zmk,behavior-smart-interrupt.yaml => zmk,behavior-tri-state.yaml} (83%)
 delete mode 100644 app/src/behaviors/behavior_smart_interrupt.c
 create mode 100644 app/src/behaviors/behavior_tri_state.c

diff --git a/app/CMakeLists.txt b/app/CMakeLists.txt
index e571310..2bab5f0 100644
--- a/app/CMakeLists.txt
+++ b/app/CMakeLists.txt
@@ -51,7 +51,7 @@ if ((NOT CONFIG_ZMK_SPLIT) OR CONFIG_ZMK_SPLIT_ROLE_CENTRAL)
   target_sources(app PRIVATE src/behaviors/behavior_toggle_layer.c)
   target_sources(app PRIVATE src/behaviors/behavior_to_layer.c)
   target_sources(app PRIVATE src/behaviors/behavior_transparent.c)
-  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_SMART_INTERRUPT app PRIVATE src/behaviors/behavior_smart_interrupt.c)
+  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_TRI_STATE app PRIVATE src/behaviors/behavior_tri_state.c)
   target_sources(app PRIVATE src/behaviors/behavior_none.c)
   target_sources(app PRIVATE src/behaviors/behavior_sensor_rotate_key_press.c)
   target_sources(app PRIVATE src/combo.c)
diff --git a/app/Kconfig b/app/Kconfig
index 6acac3d..8f98e49 100644
--- a/app/Kconfig
+++ b/app/Kconfig
@@ -343,11 +343,11 @@ config ZMK_BEHAVIOR_KEY_TOGGLE
         bool
         default $(dt_compat_enabled,$(DT_COMPAT_ZMK_BEHAVIOR_KEY_TOGGLE))
 
-DT_COMPAT_ZMK_BEHAVIOR_SMART_INTERRUPT := zmk,behavior-smart-interrupt
+DT_COMPAT_ZMK_BEHAVIOR_TRI_STATE := zmk,behavior-tri-state
 
-config ZMK_BEHAVIOR_SMART_INTERRUPT
+config ZMK_BEHAVIOR_TRI_STATE
         bool
-        default $(dt_compat_enabled,$(DT_COMPAT_ZMK_BEHAVIOR_SMART_INTERRUPT))
+        default $(dt_compat_enabled,$(DT_COMPAT_ZMK_BEHAVIOR_TRI_STATE))
 
 endmenu
 
diff --git a/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml b/app/dts/bindings/behaviors/zmk,behavior-tri-state.yaml
similarity index 83%
rename from app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
rename to app/dts/bindings/behaviors/zmk,behavior-tri-state.yaml
index 287557d..bf9eb5d 100644
--- a/app/dts/bindings/behaviors/zmk,behavior-smart-interrupt.yaml
+++ b/app/dts/bindings/behaviors/zmk,behavior-tri-state.yaml
@@ -1,9 +1,9 @@
 # Copyright (c) 2022 The ZMK Contributors
 # SPDX-License-Identifier: MIT
 
-description: Smart Interrupt Behavior
+description: Tri-State Behavior
 
-compatible: "zmk,behavior-smart-interrupt"
+compatible: "zmk,behavior-tri-state"
 
 include: zero_param.yaml
 
diff --git a/app/src/behaviors/behavior_smart_interrupt.c b/app/src/behaviors/behavior_smart_interrupt.c
deleted file mode 100644
index f56fcac..0000000
--- a/app/src/behaviors/behavior_smart_interrupt.c
+++ /dev/null
@@ -1,311 +0,0 @@
-/*
- * Copyright (c) 2022 The ZMK Contributors
- *
- * SPDX-License-Identifier: MIT
- */
-
-#define DT_DRV_COMPAT zmk_behavior_smart_interrupt
-
-#include <device.h>
-#include <drivers/behavior.h>
-#include <logging/log.h>
-#include <zmk/behavior.h>
-#include <zmk/behavior_queue.h>
-#include <zmk/keymap.h>
-#include <zmk/matrix.h>
-#include <zmk/event_manager.h>
-#include <zmk/events/position_state_changed.h>
-#include <zmk/events/layer_state_changed.h>
-#include <zmk/hid.h>
-
-LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
-
-#define ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS 10
-
-struct behavior_smart_interrupt_config {
-    int32_t ignored_key_positions_len;
-    int32_t ignored_layers_len;
-    struct zmk_behavior_binding start_behavior;
-    struct zmk_behavior_binding continue_behavior;
-    struct zmk_behavior_binding end_behavior;
-    int32_t ignored_layers;
-    int32_t timeout_ms;
-    int tap_ms;
-    uint8_t ignored_key_positions[];
-};
-
-struct active_smart_interrupt {
-    bool is_active;
-    bool is_pressed;
-    bool first_press;
-    uint32_t position;
-    const struct behavior_smart_interrupt_config *config;
-    struct k_work_delayable release_timer;
-    int64_t release_at;
-    bool timer_started;
-    bool timer_cancelled;
-};
-
-static int stop_timer(struct active_smart_interrupt *smart_interrupt) {
-    int timer_cancel_result = k_work_cancel_delayable(&smart_interrupt->release_timer);
-    if (timer_cancel_result == -EINPROGRESS) {
-        // too late to cancel, we'll let the timer handler clear up.
-        smart_interrupt->timer_cancelled = true;
-    }
-    return timer_cancel_result;
-}
-
-static void reset_timer(int32_t timestamp, struct active_smart_interrupt *smart_interrupt) {
-    smart_interrupt->release_at = timestamp + smart_interrupt->config->timeout_ms;
-    int32_t ms_left = smart_interrupt->release_at - k_uptime_get();
-    if (ms_left > 0) {
-        k_work_schedule(&smart_interrupt->release_timer, K_MSEC(ms_left));
-        LOG_DBG("Successfully reset smart interrupt timer");
-    }
-}
-
-void trigger_end_behavior(struct active_smart_interrupt *si) {
-    zmk_behavior_queue_add(si->position, si->config->end_behavior, true, si->config->tap_ms);
-    zmk_behavior_queue_add(si->position, si->config->end_behavior, false, 0);
-}
-
-void behavior_smart_interrupt_timer_handler(struct k_work *item) {
-    struct active_smart_interrupt *smart_interrupt =
-        CONTAINER_OF(item, struct active_smart_interrupt, release_timer);
-    if (!smart_interrupt->is_active || smart_interrupt->timer_cancelled ||
-        smart_interrupt->is_pressed) {
-        return;
-    }
-    LOG_DBG("Smart interrupted deactivated due to timer");
-    smart_interrupt->is_active = false;
-    trigger_end_behavior(smart_interrupt);
-}
-
-static void clear_smart_interrupt(struct active_smart_interrupt *smart_interrupt) {
-    smart_interrupt->is_active = false;
-}
-
-struct active_smart_interrupt active_smart_interrupts[ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS] = {};
-
-static struct active_smart_interrupt *find_smart_interrupt(uint32_t position) {
-    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
-        if (active_smart_interrupts[i].position == position &&
-            active_smart_interrupts[i].is_active) {
-            return &active_smart_interrupts[i];
-        }
-    }
-    return NULL;
-}
-
-static int new_smart_interrupt(uint32_t position,
-                               const struct behavior_smart_interrupt_config *config,
-                               struct active_smart_interrupt **smart_interrupt) {
-    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
-        struct active_smart_interrupt *const ref_smart_interrupt = &active_smart_interrupts[i];
-        if (!ref_smart_interrupt->is_active) {
-            ref_smart_interrupt->position = position;
-            ref_smart_interrupt->config = config;
-            ref_smart_interrupt->is_active = true;
-            ref_smart_interrupt->is_pressed = false;
-            ref_smart_interrupt->first_press = true;
-            *smart_interrupt = ref_smart_interrupt;
-            return 0;
-        }
-    }
-    return -ENOMEM;
-}
-
-static bool is_other_key_ignored(struct active_smart_interrupt *smart_interrupt, int32_t position) {
-    for (int i = 0; i < smart_interrupt->config->ignored_key_positions_len; i++) {
-        if (smart_interrupt->config->ignored_key_positions[i] == position) {
-            return true;
-        }
-    }
-    return false;
-}
-
-static bool is_layer_ignored(struct active_smart_interrupt *smart_interrupt, int32_t layer) {
-    if ((BIT(layer) & smart_interrupt->config->ignored_layers) != 0U) {
-        return true;
-    }
-    return false;
-}
-
-static int on_smart_interrupt_binding_pressed(struct zmk_behavior_binding *binding,
-                                              struct zmk_behavior_binding_event event) {
-    const struct device *dev = device_get_binding(binding->behavior_dev);
-    const struct behavior_smart_interrupt_config *cfg = dev->config;
-    struct active_smart_interrupt *smart_interrupt;
-    smart_interrupt = find_smart_interrupt(event.position);
-    if (smart_interrupt == NULL) {
-        if (new_smart_interrupt(event.position, cfg, &smart_interrupt) == -ENOMEM) {
-            LOG_ERR("Unable to create new smart_interrupt. Insufficient space in "
-                    "active_smart_interrupts[].");
-            return ZMK_BEHAVIOR_OPAQUE;
-        }
-        LOG_DBG("%d created new smart_interrupt", event.position);
-    }
-    LOG_DBG("%d smart_interrupt pressed", event.position);
-    smart_interrupt->is_pressed = true;
-    if (smart_interrupt->first_press) {
-        behavior_keymap_binding_pressed((struct zmk_behavior_binding *)&cfg->start_behavior, event);
-        behavior_keymap_binding_released((struct zmk_behavior_binding *)&cfg->start_behavior,
-                                         event);
-        smart_interrupt->first_press = false;
-    }
-    behavior_keymap_binding_pressed((struct zmk_behavior_binding *)&cfg->continue_behavior, event);
-    return ZMK_BEHAVIOR_OPAQUE;
-}
-
-static void release_smart_interrupt(struct zmk_behavior_binding_event event,
-                                    struct zmk_behavior_binding *continue_behavior) {
-    struct active_smart_interrupt *smart_interrupt = find_smart_interrupt(event.position);
-    if (smart_interrupt == NULL) {
-        return;
-    }
-    smart_interrupt->is_pressed = false;
-    behavior_keymap_binding_released(continue_behavior, event);
-    reset_timer(k_uptime_get(), smart_interrupt);
-}
-
-static int on_smart_interrupt_binding_released(struct zmk_behavior_binding *binding,
-                                               struct zmk_behavior_binding_event event) {
-    const struct device *dev = device_get_binding(binding->behavior_dev);
-    const struct behavior_smart_interrupt_config *cfg = dev->config;
-    LOG_DBG("%d smart_interrupt keybind released", event.position);
-    release_smart_interrupt(event, (struct zmk_behavior_binding *)&cfg->continue_behavior);
-    return ZMK_BEHAVIOR_OPAQUE;
-}
-
-static int behavior_smart_interrupt_init(const struct device *dev) {
-    static bool init_first_run = true;
-    if (init_first_run) {
-        for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
-            k_work_init_delayable(&active_smart_interrupts[i].release_timer,
-                                  behavior_smart_interrupt_timer_handler);
-            clear_smart_interrupt(&active_smart_interrupts[i]);
-        }
-    }
-    init_first_run = false;
-    return 0;
-}
-
-static const struct behavior_driver_api behavior_smart_interrupt_driver_api = {
-    .binding_pressed = on_smart_interrupt_binding_pressed,
-    .binding_released = on_smart_interrupt_binding_released,
-};
-
-static int smart_interrupt_listener(const zmk_event_t *eh);
-static int smart_interrupt_position_state_changed_listener(const zmk_event_t *eh);
-static int smart_interrupt_layer_state_changed_listener(const zmk_event_t *eh);
-
-ZMK_LISTENER(behavior_smart_interrupt, smart_interrupt_listener);
-ZMK_SUBSCRIPTION(behavior_smart_interrupt, zmk_position_state_changed);
-ZMK_SUBSCRIPTION(behavior_smart_interrupt, zmk_layer_state_changed);
-
-static int smart_interrupt_listener(const zmk_event_t *eh) {
-    if (as_zmk_position_state_changed(eh) != NULL) {
-        return smart_interrupt_position_state_changed_listener(eh);
-    } else if (as_zmk_layer_state_changed(eh) != NULL) {
-        return smart_interrupt_layer_state_changed_listener(eh);
-    }
-    return ZMK_EV_EVENT_BUBBLE;
-}
-
-static int smart_interrupt_position_state_changed_listener(const zmk_event_t *eh) {
-    struct zmk_position_state_changed *ev = as_zmk_position_state_changed(eh);
-    if (ev == NULL) {
-        return ZMK_EV_EVENT_BUBBLE;
-    }
-    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
-        struct active_smart_interrupt *smart_interrupt = &active_smart_interrupts[i];
-        if (!smart_interrupt->is_active) {
-            continue;
-        }
-        if (smart_interrupt->position == ev->position) {
-            continue;
-        }
-        if (!is_other_key_ignored(smart_interrupt, ev->position)) {
-            LOG_DBG("Smart Interrupt interrupted, ending at %d %d", smart_interrupt->position,
-                    ev->position);
-            smart_interrupt->is_active = false;
-            struct zmk_behavior_binding_event event = {.position = smart_interrupt->position,
-                                                       .timestamp = k_uptime_get()};
-            if (smart_interrupt->is_pressed) {
-                behavior_keymap_binding_released(
-                    (struct zmk_behavior_binding *)&smart_interrupt->config->continue_behavior,
-                    event);
-            }
-            trigger_end_behavior(smart_interrupt);
-            return ZMK_EV_EVENT_BUBBLE;
-        }
-        if (ev->state) {
-            stop_timer(smart_interrupt);
-        } else {
-            reset_timer(ev->timestamp, smart_interrupt);
-        }
-    }
-    return ZMK_EV_EVENT_BUBBLE;
-}
-
-static int smart_interrupt_layer_state_changed_listener(const zmk_event_t *eh) {
-    struct zmk_layer_state_changed *ev = as_zmk_layer_state_changed(eh);
-    if (ev == NULL) {
-        return ZMK_EV_EVENT_BUBBLE;
-    }
-    if (!ev->state) {
-        return ZMK_EV_EVENT_BUBBLE;
-    }
-    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_SMART_INTERRUPTS; i++) {
-        struct active_smart_interrupt *smart_interrupt = &active_smart_interrupts[i];
-        if (!smart_interrupt->is_active) {
-            continue;
-        }
-        if (!is_layer_ignored(smart_interrupt, ev->layer)) {
-            LOG_DBG("Smart Interrupt layer changed, ending at %d %d", smart_interrupt->position,
-                    ev->layer);
-            smart_interrupt->is_active = false;
-            struct zmk_behavior_binding_event event = {.position = smart_interrupt->position,
-                                                       .timestamp = k_uptime_get()};
-            if (smart_interrupt->is_pressed) {
-                behavior_keymap_binding_released(
-                    (struct zmk_behavior_binding *)&smart_interrupt->config->continue_behavior,
-                    event);
-            }
-            behavior_keymap_binding_pressed(
-                (struct zmk_behavior_binding *)&smart_interrupt->config->end_behavior, event);
-            behavior_keymap_binding_released(
-                (struct zmk_behavior_binding *)&smart_interrupt->config->end_behavior, event);
-            return ZMK_EV_EVENT_BUBBLE;
-        }
-    }
-    return ZMK_EV_EVENT_BUBBLE;
-}
-
-#define _TRANSFORM_ENTRY(idx, node)                                                                \
-    {                                                                                              \
-        .behavior_dev = DT_LABEL(DT_INST_PHANDLE_BY_IDX(node, bindings, idx)),                     \
-        .param1 = COND_CODE_0(DT_INST_PHA_HAS_CELL_AT_IDX(node, bindings, idx, param1), (0),       \
-                              (DT_INST_PHA_BY_IDX(node, bindings, idx, param1))),                  \
-        .param2 = COND_CODE_0(DT_INST_PHA_HAS_CELL_AT_IDX(node, bindings, idx, param2), (0),       \
-                              (DT_INST_PHA_BY_IDX(node, bindings, idx, param2))),                  \
-    }
-
-#define IF_BIT(n, prop, i) BIT(DT_PROP_BY_IDX(n, prop, i)) |
-
-#define SMART_INTERRUPT_INST(n)                                                                    \
-    static struct behavior_smart_interrupt_config behavior_smart_interrupt_config_##n = {          \
-        .ignored_key_positions = DT_INST_PROP(n, ignored_key_positions),                           \
-        .ignored_key_positions_len = DT_INST_PROP_LEN(n, ignored_key_positions),                   \
-        .ignored_layers = DT_INST_FOREACH_PROP_ELEM(n, ignored_layers, IF_BIT) 0,                  \
-        .ignored_layers_len = DT_INST_PROP_LEN(n, ignored_layers),                                 \
-        .timeout_ms = DT_INST_PROP(n, timeout_ms),                                                 \
-        .tap_ms = DT_INST_PROP(n, tap_ms),                                                         \
-        .start_behavior = _TRANSFORM_ENTRY(0, n),                                                  \
-        .continue_behavior = _TRANSFORM_ENTRY(1, n),                                               \
-        .end_behavior = _TRANSFORM_ENTRY(2, n)};                                                   \
-    DEVICE_DT_INST_DEFINE(                                                                         \
-        n, behavior_smart_interrupt_init, NULL, NULL, &behavior_smart_interrupt_config_##n,        \
-        APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, &behavior_smart_interrupt_driver_api);
-
-DT_INST_FOREACH_STATUS_OKAY(SMART_INTERRUPT_INST)
diff --git a/app/src/behaviors/behavior_tri_state.c b/app/src/behaviors/behavior_tri_state.c
new file mode 100644
index 0000000..1338e05
--- /dev/null
+++ b/app/src/behaviors/behavior_tri_state.c
@@ -0,0 +1,301 @@
+/*
+ * Copyright (c) 2022 The ZMK Contributors
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#define DT_DRV_COMPAT zmk_behavior_tri_state
+
+#include <device.h>
+#include <drivers/behavior.h>
+#include <logging/log.h>
+#include <zmk/behavior.h>
+#include <zmk/behavior_queue.h>
+#include <zmk/keymap.h>
+#include <zmk/matrix.h>
+#include <zmk/event_manager.h>
+#include <zmk/events/position_state_changed.h>
+#include <zmk/events/layer_state_changed.h>
+#include <zmk/hid.h>
+
+LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
+
+#define ZMK_BHV_MAX_ACTIVE_TRI_STATES 10
+
+struct behavior_tri_state_config {
+    int32_t ignored_key_positions_len;
+    int32_t ignored_layers_len;
+    struct zmk_behavior_binding start_behavior;
+    struct zmk_behavior_binding continue_behavior;
+    struct zmk_behavior_binding end_behavior;
+    int32_t ignored_layers;
+    int32_t timeout_ms;
+    int tap_ms;
+    uint8_t ignored_key_positions[];
+};
+
+struct active_tri_state {
+    bool is_active;
+    bool is_pressed;
+    bool first_press;
+    uint32_t position;
+    const struct behavior_tri_state_config *config;
+    struct k_work_delayable release_timer;
+    int64_t release_at;
+    bool timer_started;
+    bool timer_cancelled;
+};
+
+static int stop_timer(struct active_tri_state *tri_state) {
+    int timer_cancel_result = k_work_cancel_delayable(&tri_state->release_timer);
+    if (timer_cancel_result == -EINPROGRESS) {
+        // too late to cancel, we'll let the timer handler clear up.
+        tri_state->timer_cancelled = true;
+    }
+    return timer_cancel_result;
+}
+
+static void reset_timer(int32_t timestamp, struct active_tri_state *tri_state) {
+    tri_state->release_at = timestamp + tri_state->config->timeout_ms;
+    int32_t ms_left = tri_state->release_at - k_uptime_get();
+    if (ms_left > 0) {
+        k_work_schedule(&tri_state->release_timer, K_MSEC(ms_left));
+        LOG_DBG("Successfully reset tri-state timer");
+    }
+}
+
+void trigger_end_behavior(struct active_tri_state *si) {
+    zmk_behavior_queue_add(si->position, si->config->end_behavior, true, si->config->tap_ms);
+    zmk_behavior_queue_add(si->position, si->config->end_behavior, false, 0);
+}
+
+void behavior_tri_state_timer_handler(struct k_work *item) {
+    struct active_tri_state *tri_state = CONTAINER_OF(item, struct active_tri_state, release_timer);
+    if (!tri_state->is_active || tri_state->timer_cancelled || tri_state->is_pressed) {
+        return;
+    }
+    LOG_DBG("Tri-state deactivated due to timer");
+    tri_state->is_active = false;
+    trigger_end_behavior(tri_state);
+}
+
+static void clear_tri_state(struct active_tri_state *tri_state) { tri_state->is_active = false; }
+
+struct active_tri_state active_tri_states[ZMK_BHV_MAX_ACTIVE_TRI_STATES] = {};
+
+static struct active_tri_state *find_tri_state(uint32_t position) {
+    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_TRI_STATES; i++) {
+        if (active_tri_states[i].position == position && active_tri_states[i].is_active) {
+            return &active_tri_states[i];
+        }
+    }
+    return NULL;
+}
+
+static int new_tri_state(uint32_t position, const struct behavior_tri_state_config *config,
+                         struct active_tri_state **tri_state) {
+    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_TRI_STATES; i++) {
+        struct active_tri_state *const ref_tri_state = &active_tri_states[i];
+        if (!ref_tri_state->is_active) {
+            ref_tri_state->position = position;
+            ref_tri_state->config = config;
+            ref_tri_state->is_active = true;
+            ref_tri_state->is_pressed = false;
+            ref_tri_state->first_press = true;
+            *tri_state = ref_tri_state;
+            return 0;
+        }
+    }
+    return -ENOMEM;
+}
+
+static bool is_other_key_ignored(struct active_tri_state *tri_state, int32_t position) {
+    for (int i = 0; i < tri_state->config->ignored_key_positions_len; i++) {
+        if (tri_state->config->ignored_key_positions[i] == position) {
+            return true;
+        }
+    }
+    return false;
+}
+
+static bool is_layer_ignored(struct active_tri_state *tri_state, int32_t layer) {
+    if ((BIT(layer) & tri_state->config->ignored_layers) != 0U) {
+        return true;
+    }
+    return false;
+}
+
+static int on_tri_state_binding_pressed(struct zmk_behavior_binding *binding,
+                                        struct zmk_behavior_binding_event event) {
+    const struct device *dev = device_get_binding(binding->behavior_dev);
+    const struct behavior_tri_state_config *cfg = dev->config;
+    struct active_tri_state *tri_state;
+    tri_state = find_tri_state(event.position);
+    if (tri_state == NULL) {
+        if (new_tri_state(event.position, cfg, &tri_state) == -ENOMEM) {
+            LOG_ERR("Unable to create new tri_state. Insufficient space in "
+                    "active_tri_states[].");
+            return ZMK_BEHAVIOR_OPAQUE;
+        }
+        LOG_DBG("%d created new tri_state", event.position);
+    }
+    LOG_DBG("%d tri_state pressed", event.position);
+    tri_state->is_pressed = true;
+    if (tri_state->first_press) {
+        behavior_keymap_binding_pressed((struct zmk_behavior_binding *)&cfg->start_behavior, event);
+        behavior_keymap_binding_released((struct zmk_behavior_binding *)&cfg->start_behavior,
+                                         event);
+        tri_state->first_press = false;
+    }
+    behavior_keymap_binding_pressed((struct zmk_behavior_binding *)&cfg->continue_behavior, event);
+    return ZMK_BEHAVIOR_OPAQUE;
+}
+
+static void release_tri_state(struct zmk_behavior_binding_event event,
+                              struct zmk_behavior_binding *continue_behavior) {
+    struct active_tri_state *tri_state = find_tri_state(event.position);
+    if (tri_state == NULL) {
+        return;
+    }
+    tri_state->is_pressed = false;
+    behavior_keymap_binding_released(continue_behavior, event);
+    reset_timer(k_uptime_get(), tri_state);
+}
+
+static int on_tri_state_binding_released(struct zmk_behavior_binding *binding,
+                                         struct zmk_behavior_binding_event event) {
+    const struct device *dev = device_get_binding(binding->behavior_dev);
+    const struct behavior_tri_state_config *cfg = dev->config;
+    LOG_DBG("%d tri_state keybind released", event.position);
+    release_tri_state(event, (struct zmk_behavior_binding *)&cfg->continue_behavior);
+    return ZMK_BEHAVIOR_OPAQUE;
+}
+
+static int behavior_tri_state_init(const struct device *dev) {
+    static bool init_first_run = true;
+    if (init_first_run) {
+        for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_TRI_STATES; i++) {
+            k_work_init_delayable(&active_tri_states[i].release_timer,
+                                  behavior_tri_state_timer_handler);
+            clear_tri_state(&active_tri_states[i]);
+        }
+    }
+    init_first_run = false;
+    return 0;
+}
+
+static const struct behavior_driver_api behavior_tri_state_driver_api = {
+    .binding_pressed = on_tri_state_binding_pressed,
+    .binding_released = on_tri_state_binding_released,
+};
+
+static int tri_state_listener(const zmk_event_t *eh);
+static int tri_state_position_state_changed_listener(const zmk_event_t *eh);
+static int tri_state_layer_state_changed_listener(const zmk_event_t *eh);
+
+ZMK_LISTENER(behavior_tri_state, tri_state_listener);
+ZMK_SUBSCRIPTION(behavior_tri_state, zmk_position_state_changed);
+ZMK_SUBSCRIPTION(behavior_tri_state, zmk_layer_state_changed);
+
+static int tri_state_listener(const zmk_event_t *eh) {
+    if (as_zmk_position_state_changed(eh) != NULL) {
+        return tri_state_position_state_changed_listener(eh);
+    } else if (as_zmk_layer_state_changed(eh) != NULL) {
+        return tri_state_layer_state_changed_listener(eh);
+    }
+    return ZMK_EV_EVENT_BUBBLE;
+}
+
+static int tri_state_position_state_changed_listener(const zmk_event_t *eh) {
+    struct zmk_position_state_changed *ev = as_zmk_position_state_changed(eh);
+    if (ev == NULL) {
+        return ZMK_EV_EVENT_BUBBLE;
+    }
+    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_TRI_STATES; i++) {
+        struct active_tri_state *tri_state = &active_tri_states[i];
+        if (!tri_state->is_active) {
+            continue;
+        }
+        if (tri_state->position == ev->position) {
+            continue;
+        }
+        if (!is_other_key_ignored(tri_state, ev->position)) {
+            LOG_DBG("Tri-State interrupted, ending at %d %d", tri_state->position, ev->position);
+            tri_state->is_active = false;
+            struct zmk_behavior_binding_event event = {.position = tri_state->position,
+                                                       .timestamp = k_uptime_get()};
+            if (tri_state->is_pressed) {
+                behavior_keymap_binding_released(
+                    (struct zmk_behavior_binding *)&tri_state->config->continue_behavior, event);
+            }
+            trigger_end_behavior(tri_state);
+            return ZMK_EV_EVENT_BUBBLE;
+        }
+        if (ev->state) {
+            stop_timer(tri_state);
+        } else {
+            reset_timer(ev->timestamp, tri_state);
+        }
+    }
+    return ZMK_EV_EVENT_BUBBLE;
+}
+
+static int tri_state_layer_state_changed_listener(const zmk_event_t *eh) {
+    struct zmk_layer_state_changed *ev = as_zmk_layer_state_changed(eh);
+    if (ev == NULL) {
+        return ZMK_EV_EVENT_BUBBLE;
+    }
+    if (!ev->state) {
+        return ZMK_EV_EVENT_BUBBLE;
+    }
+    for (int i = 0; i < ZMK_BHV_MAX_ACTIVE_TRI_STATES; i++) {
+        struct active_tri_state *tri_state = &active_tri_states[i];
+        if (!tri_state->is_active) {
+            continue;
+        }
+        if (!is_layer_ignored(tri_state, ev->layer)) {
+            LOG_DBG("Tri-State layer changed, ending at %d %d", tri_state->position, ev->layer);
+            tri_state->is_active = false;
+            struct zmk_behavior_binding_event event = {.position = tri_state->position,
+                                                       .timestamp = k_uptime_get()};
+            if (tri_state->is_pressed) {
+                behavior_keymap_binding_released(
+                    (struct zmk_behavior_binding *)&tri_state->config->continue_behavior, event);
+            }
+            behavior_keymap_binding_pressed(
+                (struct zmk_behavior_binding *)&tri_state->config->end_behavior, event);
+            behavior_keymap_binding_released(
+                (struct zmk_behavior_binding *)&tri_state->config->end_behavior, event);
+            return ZMK_EV_EVENT_BUBBLE;
+        }
+    }
+    return ZMK_EV_EVENT_BUBBLE;
+}
+
+#define _TRANSFORM_ENTRY(idx, node)                                                                \
+    {                                                                                              \
+        .behavior_dev = DT_LABEL(DT_INST_PHANDLE_BY_IDX(node, bindings, idx)),                     \
+        .param1 = COND_CODE_0(DT_INST_PHA_HAS_CELL_AT_IDX(node, bindings, idx, param1), (0),       \
+                              (DT_INST_PHA_BY_IDX(node, bindings, idx, param1))),                  \
+        .param2 = COND_CODE_0(DT_INST_PHA_HAS_CELL_AT_IDX(node, bindings, idx, param2), (0),       \
+                              (DT_INST_PHA_BY_IDX(node, bindings, idx, param2))),                  \
+    }
+
+#define IF_BIT(n, prop, i) BIT(DT_PROP_BY_IDX(n, prop, i)) |
+
+#define TRI_STATE_INST(n)                                                                          \
+    static struct behavior_tri_state_config behavior_tri_state_config_##n = {                      \
+        .ignored_key_positions = DT_INST_PROP(n, ignored_key_positions),                           \
+        .ignored_key_positions_len = DT_INST_PROP_LEN(n, ignored_key_positions),                   \
+        .ignored_layers = DT_INST_FOREACH_PROP_ELEM(n, ignored_layers, IF_BIT) 0,                  \
+        .ignored_layers_len = DT_INST_PROP_LEN(n, ignored_layers),                                 \
+        .timeout_ms = DT_INST_PROP(n, timeout_ms),                                                 \
+        .tap_ms = DT_INST_PROP(n, tap_ms),                                                         \
+        .start_behavior = _TRANSFORM_ENTRY(0, n),                                                  \
+        .continue_behavior = _TRANSFORM_ENTRY(1, n),                                               \
+        .end_behavior = _TRANSFORM_ENTRY(2, n)};                                                   \
+    DEVICE_DT_INST_DEFINE(n, behavior_tri_state_init, NULL, NULL, &behavior_tri_state_config_##n,  \
+                          APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT,                        \
+                          &behavior_tri_state_driver_api);
+
+DT_INST_FOREACH_STATUS_OKAY(TRI_STATE_INST)
-- 
2.30.2

